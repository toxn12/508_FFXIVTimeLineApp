import React, { useState, useEffect } from 'react';
import { Plus, Trash2, Save, Share2, Copy, Settings, Target, Edit2, ChevronDown, ChevronUp, GripVertical } from 'lucide-react';

const FF14RaidTimeline = () => {
  const jobs = [
    '„Éä„Ç§„Éà', 'Êà¶Â£´', '„Ç¨„É≥„Éñ„É¨„Ç§„Ç´„Éº', 'ÊöóÈªíÈ®éÂ£´',
    'ÁôΩÈ≠îÈÅìÂ£´', 'Â≠¶ËÄÖ', 'Âç†ÊòüË°ìÂ∏´', 'Ë≥¢ËÄÖ',
    '„É¢„É≥„ÇØ', 'Á´úÈ®éÂ£´', 'ÂøçËÄÖ', '‰æç', '„É™„Éº„Éë„Éº',
    'ÂêüÈÅäË©©‰∫∫', 'Ê©üÂ∑•Â£´', 'Ë∏ä„ÇäÂ≠ê',
    'ÈªíÈ≠îÈÅìÂ£´', 'Âè¨ÂñöÂ£´', 'Ëµ§È≠îÈÅìÂ£´'
  ];

  const [selectedBoss, setSelectedBoss] = useState('‰∏áÈ≠îÊÆø„Éë„É≥„Éá„É¢„Éã„Ç¶„É†Èõ∂ÂºèÔºöÁÖâÁçÑÁ∑®1Â±§');
  const [partyName, setPartyName] = useState('Âõ∫ÂÆö„Éë„Éº„ÉÜ„Ç£1');
  const [partyMembers, setPartyMembers] = useState(
    Array(8).fill(null).map((_, i) => ({
      id: i,
      job: jobs[i],
      playerName: '',
      order: i
    }))
  );

  const [timelineDuration, setTimelineDuration] = useState(600);
  const pixelsPerSecond = 3;
  const [targets, setTargets] = useState(['„Éú„Çπ', 'ÈõëÈ≠öA', 'ÈõëÈ≠öB']);
  const [phases, setPhases] = useState([
    {
      id: 1,
      name: 'ÈñãÂπï',
      nickname: '„Ç´„Ç¶„É≥„Éà',
      startTime: 0,
      endTime: 60,
      color: '#9333ea'
    }
  ]);
  const [mechanics, setMechanics] = useState([
    { 
      id: 1, 
      time: 5, 
      name: '„Çø„É≥„ÇØÂº∑ÊîªÊíÉ', 
      phaseId: 1,
      castTime: 3,
      assignedGroup: null
    }
  ]);
  const [skills, setSkills] = useState([]);
  const [collapsedPhases, setCollapsedPhases] = useState(new Set());
  const [draggedMechanic, setDraggedMechanic] = useState(null);
  const [resizingPhase, setResizingPhase] = useState(null);
  const [draggedJobIndex, setDraggedJobIndex] = useState(null);
  const [contextMenu, setContextMenu] = useState(null);

  const [savedPatterns, setSavedPatterns] = useState([]);
  const [showShareModal, setShowShareModal] = useState(false);
  const [showSettingsModal, setShowSettingsModal] = useState(false);
  const [showPlayerNamesModal, setShowPlayerNamesModal] = useState(false);

  useEffect(() => {
    loadPatterns();
  }, []);

  useEffect(() => {
    const handleClick = () => setContextMenu(null);
    document.addEventListener('click', handleClick);
    return () => document.removeEventListener('click', handleClick);
  }, []);

  const loadPatterns = async () => {
    try {
      const keys = await window.storage.list('ff14-pattern:');
      if (keys && keys.keys) {
        const patterns = [];
        for (const key of keys.keys) {
          const result = await window.storage.get(key, true);
          if (result) {
            patterns.push(JSON.parse(result.value));
          }
        }
        setSavedPatterns(patterns);
      }
    } catch (error) {
      console.log('„Éë„Çø„Éº„É≥Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
    }
  };

  const savePattern = async () => {
    const pattern = {
      id: Date.now(),
      boss: selectedBoss,
      partyName,
      members: partyMembers,
      duration: timelineDuration,
      targets,
      phases,
      mechanics,
      skills,
      createdAt: new Date().toISOString()
    };

    try {
      await window.storage.set(`ff14-pattern:${pattern.id}`, JSON.stringify(pattern), true);
      await loadPatterns();
      alert('„Éë„Çø„Éº„É≥„Çí‰øùÂ≠ò„Åó„Åæ„Åó„ÅüÔºÅ');
    } catch (error) {
      alert('‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
  };

  const loadPattern = async (patternId) => {
    try {
      const result = await window.storage.get(`ff14-pattern:${patternId}`, true);
      if (result) {
        const pattern = JSON.parse(result.value);
        setSelectedBoss(pattern.boss);
        setPartyName(pattern.partyName);
        setPartyMembers(pattern.members.map((m, i) => ({ ...m, order: m.order ?? i })));
        setTimelineDuration(pattern.duration);
        setTargets(pattern.targets || ['„Éú„Çπ']);
        setPhases(pattern.phases || []);
        setMechanics(pattern.mechanics || []);
        setSkills(pattern.skills || []);
      }
    } catch (error) {
      alert('„Éë„Çø„Éº„É≥„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
  };

  const deletePattern = async (patternId) => {
    if (confirm('„Åì„ÅÆ„Éë„Çø„Éº„É≥„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
      try {
        await window.storage.delete(`ff14-pattern:${patternId}`, true);
        await loadPatterns();
      } catch (error) {
        alert('ÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
      }
    }
  };

  const addPhase = () => {
    const lastPhase = phases.length > 0 ? phases[phases.length - 1] : null;
    const newPhase = {
      id: Date.now(),
      name: 'Êñ∞„Åó„ÅÑ„Éï„Çß„Éº„Ç∫',
      nickname: '',
      startTime: lastPhase ? lastPhase.endTime : 0,
      endTime: lastPhase ? lastPhase.endTime + 60 : 60,
      color: '#' + Math.floor(Math.random()*16777215).toString(16)
    };
    setPhases([...phases, newPhase]);
  };

  const updatePhase = (phaseId, field, value) => {
    setPhases(phases.map(p => 
      p.id === phaseId ? { ...p, [field]: value } : p
    ));
  };

  const deletePhase = (phaseId) => {
    if (confirm('„Åì„ÅÆ„Éï„Çß„Éº„Ç∫„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
      setPhases(phases.filter(p => p.id !== phaseId));
      setMechanics(mechanics.filter(m => m.phaseId !== phaseId));
      setCollapsedPhases(new Set([...collapsedPhases].filter(id => id !== phaseId)));
    }
  };

  const togglePhaseCollapse = (phaseId) => {
    const newCollapsed = new Set(collapsedPhases);
    if (newCollapsed.has(phaseId)) {
      newCollapsed.delete(phaseId);
    } else {
      newCollapsed.add(phaseId);
    }
    setCollapsedPhases(newCollapsed);
  };

  const addMechanic = (time) => {
    const phase = phases.find(p => time >= p.startTime && time < p.endTime);
    const newMechanic = {
      id: Date.now(),
      time,
      name: 'Êñ∞„Åó„ÅÑ„ÇÆ„Éü„ÉÉ„ÇØ',
      phaseId: phase ? phase.id : (phases.length > 0 ? phases[0].id : null),
      castTime: 0,
      assignedGroup: null
    };
    setMechanics([...mechanics, newMechanic]);
  };

  const updateMechanic = (mechanicId, field, value) => {
    setMechanics(mechanics.map(m =>
      m.id === mechanicId ? { ...m, [field]: value } : m
    ));
  };

  const deleteMechanic = (mechanicId) => {
    setMechanics(mechanics.filter(m => m.id !== mechanicId));
  };

  const handleMechanicDragStart = (e, mechanic) => {
    setDraggedMechanic(mechanic);
  };

  const handleMechanicDrop = (e) => {
    e.preventDefault();
    if (draggedMechanic) {
      const rect = e.currentTarget.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const newTime = Math.max(0, Math.min(timelineDuration - 1, Math.floor(x / pixelsPerSecond)));
      
      const phase = phases.find(p => newTime >= p.startTime && newTime < p.endTime);
      updateMechanic(draggedMechanic.id, 'time', newTime);
      if (phase) {
        updateMechanic(draggedMechanic.id, 'phaseId', phase.id);
      }
      setDraggedMechanic(null);
    }
  };

  const handleMechanicAreaClick = (e) => {
    if (e.target !== e.currentTarget) return;
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const clickedTime = Math.floor(x / pixelsPerSecond);
    addMechanic(clickedTime);
  };

  const handlePhaseResizeStart = (e, phaseId) => {
    e.stopPropagation();
    setResizingPhase(phaseId);
  };

  const handlePhaseResize = (e) => {
    if (!resizingPhase) return;
    
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const newEndTime = Math.max(1, Math.min(timelineDuration, Math.floor(x / pixelsPerSecond)));
    
    const phase = phases.find(p => p.id === resizingPhase);
    if (phase && newEndTime > phase.startTime) {
      updatePhase(resizingPhase, 'endTime', newEndTime);
    }
  };

  const handlePhaseResizeEnd = () => {
    setResizingPhase(null);
  };

  const addSkill = (memberId, time) => {
    const newSkill = {
      id: Date.now(),
      memberId,
      time,
      skillName: 'Êñ∞„Åó„ÅÑ„Çπ„Ç≠„É´',
      skillType: 'weaponskill',
      target: targets[0],
      duration: 0,
      buffDuration: 0
    };
    setSkills([...skills, newSkill]);
  };

  const updateSkill = (skillId, field, value) => {
    setSkills(skills.map(s => 
      s.id === skillId ? { ...s, [field]: value } : s
    ));
  };

  const deleteSkill = (skillId) => {
    setSkills(skills.filter(s => s.id !== skillId));
  };

  const addTarget = () => {
    const newTarget = prompt('Êñ∞„Åó„ÅÑ„Çø„Éº„Ç≤„ÉÉ„ÉàÂêç„ÇíÂÖ•Âäõ:');
    if (newTarget && !targets.includes(newTarget)) {
      setTargets([...targets, newTarget]);
    }
  };

  const removeTarget = (target) => {
    if (targets.length > 1) {
      setTargets(targets.filter(t => t !== target));
      setSkills(skills.map(s => 
        s.target === target ? { ...s, target: targets[0] } : s
      ));
    }
  };

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const timeMarks = [];
  for (let i = 0; i <= timelineDuration; i += 30) {
    timeMarks.push(i);
  }

  const handleTimelineClick = (e, memberId) => {
    if (e.target !== e.currentTarget) return;
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const clickedTime = Math.floor(x / pixelsPerSecond);
    addSkill(memberId, clickedTime);
  };

  const handleJobDragStart = (e, index) => {
    setDraggedJobIndex(index);
  };

  const handleJobDragOver = (e, index) => {
    e.preventDefault();
    if (draggedJobIndex === null || draggedJobIndex === index) return;
    
    const newMembers = [...partyMembers];
    const draggedMember = newMembers[draggedJobIndex];
    newMembers.splice(draggedJobIndex, 1);
    newMembers.splice(index, 0, draggedMember);
    
    newMembers.forEach((m, i) => m.order = i);
    setPartyMembers(newMembers);
    setDraggedJobIndex(index);
  };

  const handleJobDragEnd = () => {
    setDraggedJobIndex(null);
  };

  const handleJobRightClick = (e, memberId) => {
    e.preventDefault();
    setContextMenu({
      x: e.clientX,
      y: e.clientY,
      memberId
    });
  };

  const setPlayerNameFromContext = () => {
    if (contextMenu) {
      const newName = prompt('„Éó„É¨„Ç§„É§„ÉºÂêç„ÇíÂÖ•Âäõ:');
      if (newName !== null) {
        const newMembers = [...partyMembers];
        const member = newMembers.find(m => m.id === contextMenu.memberId);
        if (member) {
          member.playerName = newName;
          setPartyMembers(newMembers);
        }
      }
    }
    setContextMenu(null);
  };

  const jobRoles = {
    '„Éä„Ç§„Éà': 'tank', 'Êà¶Â£´': 'tank', '„Ç¨„É≥„Éñ„É¨„Ç§„Ç´„Éº': 'tank', 'ÊöóÈªíÈ®éÂ£´': 'tank',
    'ÁôΩÈ≠îÈÅìÂ£´': 'healer', 'Â≠¶ËÄÖ': 'healer', 'Âç†ÊòüË°ìÂ∏´': 'healer', 'Ë≥¢ËÄÖ': 'healer',
    '„É¢„É≥„ÇØ': 'dps', 'Á´úÈ®éÂ£´': 'dps', 'ÂøçËÄÖ': 'dps', '‰æç': 'dps', '„É™„Éº„Éë„Éº': 'dps',
    'ÂêüÈÅäË©©‰∫∫': 'dps', 'Ê©üÂ∑•Â£´': 'dps', 'Ë∏ä„ÇäÂ≠ê': 'dps',
    'ÈªíÈ≠îÈÅìÂ£´': 'dps', 'Âè¨ÂñöÂ£´': 'dps', 'Ëµ§È≠îÈÅìÂ£´': 'dps'
  };

  const roleColors = {
    'tank': 'bg-blue-600',
    'healer': 'bg-green-600',
    'dps': 'bg-red-600'
  };

  const getJobColor = (job) => {
    const role = jobRoles[job];
    return roleColors[role] || 'bg-slate-600';
  };

  const isBuffOverlappingMechanic = (skill) => {
    if (skill.buffDuration === 0) return false;
    
    const buffEndTime = skill.time + skill.buffDuration;
    return mechanics.some(mech => {
      const mechStartTime = mech.time - (mech.castTime || 0);
      const mechEndTime = mech.time;
      return (skill.time <= mechEndTime && buffEndTime >= mechStartTime);
    });
  };

  const sortedMembers = [...partyMembers].sort((a, b) => a.order - b.order);
  const timelineWidth = timelineDuration * pixelsPerSecond;

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-4">
      <div className="max-w-[1800px] mx-auto">
        <div className="bg-slate-800/90 backdrop-blur rounded-lg p-4 mb-4 border border-purple-500/30">
          <div className="flex items-center justify-between mb-4">
            <h1 className="text-2xl font-bold text-white">FF14 Èõ∂Âºè„Çø„Ç§„É†„É©„Ç§„É≥ÔºàÊ®™Âêë„ÅçÔºâ</h1>
            <div className="flex gap-2">
              <button onClick={() => setShowPlayerNamesModal(true)} className="bg-slate-600 hover:bg-slate-700 text-white rounded px-4 py-2 flex items-center gap-2">
                <Edit2 size={18} />
                „Éó„É¨„Ç§„É§„ÉºÂêç
              </button>
              <button onClick={() => setShowSettingsModal(true)} className="bg-slate-600 hover:bg-slate-700 text-white rounded px-4 py-2 flex items-center gap-2">
                <Settings size={18} />
                Ë®≠ÂÆö
              </button>
              <button onClick={savePattern} className="bg-purple-600 hover:bg-purple-700 text-white rounded px-4 py-2 flex items-center gap-2">
                <Save size={18} />
                ‰øùÂ≠ò
              </button>
              <button onClick={() => setShowShareModal(true)} className="bg-blue-600 hover:bg-blue-700 text-white rounded px-4 py-2 flex items-center gap-2">
                <Share2 size={18} />
                ÂÖ±Êúâ
              </button>
            </div>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <input type="text" value={selectedBoss} onChange={(e) => setSelectedBoss(e.target.value)} className="bg-slate-700 text-white rounded px-3 py-2 border border-purple-500/30" placeholder="„Éú„ÇπÂêç" />
            <input type="text" value={partyName} onChange={(e) => setPartyName(e.target.value)} className="bg-slate-700 text-white rounded px-3 py-2 border border-purple-500/30" placeholder="„Éë„Éº„ÉÜ„Ç£Âêç" />
          </div>
        </div>

        {savedPatterns.length > 0 && (
          <div className="bg-slate-800/90 backdrop-blur rounded-lg p-4 mb-4 border border-purple-500/30">
            <h2 className="text-white font-bold mb-3">‰øùÂ≠òÊ∏à„Åø„Éë„Çø„Éº„É≥</h2>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
              {savedPatterns.map(pattern => (
                <div key={pattern.id} className="bg-slate-700/50 rounded p-2 flex justify-between items-center">
                  <div className="flex-1 cursor-pointer" onClick={() => loadPattern(pattern.id)}>
                    <div className="text-white text-sm font-medium">{pattern.partyName}</div>
                    <div className="text-purple-300 text-xs">{pattern.boss}</div>
                  </div>
                  <button onClick={() => deletePattern(pattern.id)} className="text-red-400 hover:text-red-300 p-1">
                    <Trash2 size={14} />
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}

        <div className="bg-slate-800/90 backdrop-blur rounded-lg p-4 border border-purple-500/30 overflow-x-auto">
          <div className="inline-block min-w-full">
            <div className="flex border-b border-purple-500/30">
              <div className="w-32 flex-shrink-0 flex items-center justify-between bg-gradient-to-r from-purple-900/30 to-blue-900/30 text-white font-bold text-sm px-3 py-2">
                <span>„Éï„Çß„Éº„Ç∫</span>
                <button onClick={addPhase} className="bg-purple-600 hover:bg-purple-700 rounded-full p-1">
                  <Plus size={14} />
                </button>
              </div>
              <div className="relative flex-1" style={{ width: `${timelineWidth}px`, height: '40px' }} onMouseMove={handlePhaseResize} onMouseUp={handlePhaseResizeEnd} onMouseLeave={handlePhaseResizeEnd}>
                {phases.map((phase) => {
                  const isCollapsed = collapsedPhases.has(phase.id);
                  const width = (phase.endTime - phase.startTime) * pixelsPerSecond;
                  return (
                    <div key={phase.id} className="absolute top-1 bottom-1 rounded cursor-pointer group" style={{ left: `${phase.startTime * pixelsPerSecond}px`, width: `${width}px`, backgroundColor: phase.color + '30', border: `2px solid ${phase.color}` }}>
                      <div className="px-2 h-full flex items-center justify-between">
                        <div className="flex items-center gap-1 flex-1 min-w-0">
                          <button onClick={(e) => { e.stopPropagation(); togglePhaseCollapse(phase.id); }} className="text-white flex-shrink-0">
                            {isCollapsed ? <ChevronDown size={14} /> : <ChevronUp size={14} />}
                          </button>
                          <div className="flex-1 min-w-0">
                            <div className="text-white text-xs font-bold truncate">{phase.name}</div>
                          </div>
                        </div>
                        <button onClick={(e) => { e.stopPropagation(); deletePhase(phase.id); }} className="opacity-0 group-hover:opacity-100 text-red-400 flex-shrink-0">
                          <Trash2 size={12} />
                        </button>
                      </div>
                      <div className="absolute top-0 bottom-0 right-0 w-2 bg-white/20 hover:bg-white/40 cursor-ew-resize flex items-center justify-center" onMouseDown={(e) => handlePhaseResizeStart(e, phase.id)}>
                        <div className="h-8 w-0.5 bg-white/60"></div>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>

            <div className="flex border-b border-purple-500/30">
              <div className="w-32 flex-shrink-0 flex items-center justify-center text-white font-bold text-sm">ÊôÇÈñì</div>
              <div className="relative" style={{ width: `${timelineWidth}px`, height: '30px' }}>
                {timeMarks.map(time => (
                  <div key={time} className="absolute top-0 bottom-0 border-l border-slate-600" style={{ left: `${time * pixelsPerSecond}px` }}>
                    <span className="absolute top-1 left-1 text-purple-300 text-xs">{formatTime(time)}</span>
                  </div>
                ))}
              </div>
            </div>

            <div className="flex border-b border-purple-500/30">
              <div className="w-32 flex-shrink-0 flex items-center justify-center bg-red-900/30 text-white font-bold text-sm">„ÇÆ„Éü„ÉÉ„ÇØ</div>
              <div className="relative bg-red-900/10 cursor-crosshair" style={{ width: `${timelineWidth}px`, height: '60px' }} onClick={handleMechanicAreaClick} onDragOver={(e) => e.preventDefault()} onDrop={handleMechanicDrop}>
                {timeMarks.map(time => (
                  <div key={time} className="absolute top-0 bottom-0 border-l border-slate-600 pointer-events-none" style={{ left: `${time * pixelsPerSecond}px` }} />
                ))}
                {mechanics.filter(m => !collapsedPhases.has(m.phaseId)).map(mech => {
                  const castStart = mech.time - (mech.castTime || 0);
                  const hasCast = mech.castTime > 0;
                  return (
                    <div key={mech.id}>
                      {hasCast && (
                        <div className="absolute top-1 bottom-1 bg-orange-600/40 border-t-2 border-orange-600" style={{ left: `${castStart * pixelsPerSecond}px`, width: `${mech.castTime * pixelsPerSecond}px` }}>
                          <div className="text-orange-200 text-xs px-1">Ë©†Âî±‰∏≠</div>
                        </div>
                      )}
                      <div draggable onDragStart={(e) => handleMechanicDragStart(e, mech)} className="absolute top-1 bottom-1 bg-red-600 rounded px-2 py-1 cursor-move group flex items-center" style={{ left: `${mech.time * pixelsPerSecond}px`, transform: 'translateX(-50%)', minWidth: '80px' }}>
                        <div className="flex-1 min-w-0">
                          <div className="text-white text-xs font-bold truncate">{mech.name}</div>
                        </div>
                        <button onClick={(e) => { e.stopPropagation(); deleteMechanic(mech.id); }} className="opacity-0 group-hover:opacity-100 text-white bg-red-800 rounded-full p-1 flex-shrink-0 ml-1">
                          <Trash2 size={10} />
                        </button>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>

            {sortedMembers.map((member, index) => (
              <div key={member.id} className="flex border-b border-purple-500/30" draggable onDragStart={(e) => handleJobDragStart(e, index)} onDragOver={(e) => handleJobDragOver(e, index)} onDragEnd={handleJobDragEnd}>
                <div className="w-32 flex-shrink-0 cursor-move px-2 py-1" onContextMenu={(e) => handleJobRightClick(e, member.id)}>
                  <div className="flex items-center gap-1">
                    <GripVertical size={12} className="text-slate-400" />
                    <div className={`flex-1 ${getJobColor(member.job)} text-white text-xs font-bold text-center px-2 py-1 rounded`}>{member.job}</div>
                  </div>
                  {member.playerName && <div className="text-center text-purple-300 text-xs truncate mt-1">{member.playerName}</div>}
                </div>
                <div className="relative bg-slate-700/20 cursor-crosshair" style={{ width: `${timelineWidth}px`, height: '40px' }} onClick={(e) => handleTimelineClick(e, member.id)}>
                  {timeMarks.map(time => (
                    <div key={time} className="absolute top-0 bottom-0 border-l border-slate-600" style={{ left: `${time * pixelsPerSecond}px` }} />
                  ))}
                  {skills.filter(s => s.memberId === member.id).map(skill => {
                    const hasOverlap = isBuffOverlappingMechanic(skill);
                    return (
                      <div key={skill.id}>
                        <div className={`absolute top-1 bottom-1 ${getJobColor(member.job)} rounded px-2 py-1 cursor-pointer group flex items-center`} style={{ left: `${skill.time * pixelsPerSecond}px`, minWidth: '60px' }}>
                          <div className="text-white text-xs font-bold truncate">{skill.skillName}</div>
                        </div>
                        {skill.buffDuration > 0 && (
                          <div className={`absolute top-0 h-1 ${hasOverlap ? 'bg-yellow-400' : 'bg-white/40'}`} style={{ left: `${skill.time * pixelsPerSecond}px`, width: `${skill.buffDuration * pixelsPerSecond}px` }} />
                        )}
                      </div>
                    );
                  })}
                </div>
              </div>
            ))}
          </div>
        </div>

        <div className="mt-4 bg-slate-800/90 backdrop-blur rounded-lg p-3 border border-purple-500/30">
          <p className="text-purple-300 text-sm">üí° Ê®™Âêë„Åç„Çø„Ç§„É†„É©„Ç§„É≥: Â∑¶„Åã„ÇâÂè≥„Å∏ÊôÇÈñì„ÅåÊµÅ„Çå„Åæ„Åô | „Ç∏„Éß„Éñ„Çí„Éâ„É©„ÉÉ„Ç∞„Åß‰∏¶„ÅπÊõø„Åà | Âè≥„ÇØ„É™„ÉÉ„ÇØ„Åß„Éó„É¨„Ç§„É§„ÉºÂêçË®≠ÂÆö</p>
        </div>
      </div>

      {contextMenu && (
        <div className="fixed bg-slate-800 border border-purple-500/30 rounded shadow-lg py-1 z-50" style={{ left: contextMenu.x, top: contextMenu.y }}>
          <button onClick={setPlayerNameFromContext} className="w-full px-4 py-2 text-left text-white hover:bg-purple-600 text-sm">„Éó„É¨„Ç§„É§„ÉºÂêç„ÇíË®≠ÂÆö</button>
        </div>
      )}

      {showPlayerNamesModal && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={() => setShowPlayerNamesModal(false)}>
          <div className="bg-slate-800 rounded-lg p-6 max-w-2xl w-full mx-4" onClick={(e) => e.stopPropagation()}>
            <h3 className="text-white text-xl font-bold mb-4">„Éó„É¨„Ç§„É§„ÉºÂêçË®≠ÂÆö</h3>
            <div className="grid grid-cols-2 gap-4 mb-4">
              {sortedMembers.map((member) => (
                <div key={member.id} className="flex items-center gap-2">
                  <div className={`${getJobColor(member.job)} text-white px-3 py-2 rounded text-sm font-bold w-24 text-center`}>{member.job}</div>
                  <input type="text" value={member.playerName} onChange={(e) => { const newMembers = [...partyMembers]; const m = newMembers.find(mem => mem.id === member.id); if (m) m.playerName = e.target.value; setPartyMembers(newMembers); }} className="flex-1 bg-slate-700 text-white rounded px-3 py-2" placeholder="„Éó„É¨„Ç§„É§„ÉºÂêç" />
                </div>
              ))}
            </div>
            <button onClick={() => setShowPlayerNamesModal(false)} className="w-full bg-purple-600 hover:bg-purple-700 text-white rounded px-4 py-2">ÂÆå‰∫Ü</button>
          </div>
        </div>
      )}

      {showSettingsModal && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={() => setShowSettingsModal(false)}>
          <div className="bg-slate-800 rounded-lg p-6 max-w-md w-full mx-4" onClick={(e) => e.stopPropagation()}>
            <h3 className="text-white text-xl font-bold mb-4">Ë®≠ÂÆö</h3>
            <div className="mb-4">
              <label className="block text-purple-300 text-sm mb-2">„Çø„Ç§„É†„É©„Ç§„É≥Èï∑„ÅïÔºàÁßíÔºâ</label>
              <input type="number" value={timelineDuration} onChange={(e) => setTimelineDuration(parseInt(e.target.value))} className="w-full bg-slate-700 text-white rounded px-3 py-2" />
            </div>
            <div className="mb-4">
              <label className="block text-purple-300 text-sm mb-2">„Çø„Éº„Ç≤„ÉÉ„ÉàÁÆ°ÁêÜ</label>
              <div className="space-y-2">
                {targets.map(target => (
                  <div key={target} className="flex items-center gap-2">
                    <span className="flex-1 text-white bg-slate-700 rounded px-3 py-2">{target}</span>
                    {targets.length > 1 && (
                      <button onClick={() => removeTarget(target)} className="text-red-400 hover:text-red-300">
                        <Trash2 size={16} />
                      </button>
                    )}
                  </div>
                ))}
                <button onClick={addTarget} className="w-full bg-purple-600 hover:bg-purple-700 text-white rounded px-3 py-2 flex items-center justify-center gap-2">
                  <Plus size={16} />
                  „Çø„Éº„Ç≤„ÉÉ„ÉàËøΩÂä†
                </button>
              </div>
            </div>
            <button onClick={() => setShowSettingsModal(false)} className="w-full bg-slate-600 hover:bg-slate-700 text-white rounded px-4 py-2">Èñâ„Åò„Çã</button>
          </div>
        </div>
      )}

      {showShareModal && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={() => setShowShareModal(false)}>
          <div className="bg-slate-800 rounded-lg p-6 max-w-md w-full mx-4" onClick={(e) => e.stopPropagation()}>
            <h3 className="text-white text-xl font-bold mb-4">„Éë„Çø„Éº„É≥„ÇíÂÖ±Êúâ</h3>
            <p className="text-purple-300 mb-4">‰øùÂ≠ò„Åó„Åü„Éë„Çø„Éº„É≥„ÅØËá™ÂãïÁöÑ„Å´ÂÖ±Êúâ„Åï„Çå„ÄÅ‰ªñ„ÅÆ„É°„É≥„Éê„Éº„ÇÇÈñ≤Ë¶ß„ÉªÁ∑®ÈõÜ„Åß„Åç„Åæ„Åô„ÄÇ</p>
            <div className="flex gap-2">
              <button onClick={() => { navigator.clipboard.writeText(window.location.href); alert('URL„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ'); }} className="flex-1 bg-purple-600 hover:bg-purple-700 text-white rounded px-4 py-2 flex items-center justify-center gap-2">
                <Copy size={18} />
                URL„Çí„Ç≥„Éî„Éº
              </button>
              <button onClick={() => setShowShareModal(false)} className="flex-1 bg-slate-600 hover:bg-slate-700 text-white rounded px-4 py-2">Èñâ„Åò„Çã</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default FF14RaidTimeline;